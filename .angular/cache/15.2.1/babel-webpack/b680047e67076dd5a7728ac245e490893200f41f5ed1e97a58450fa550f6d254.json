{"ast":null,"code":"import * as i0 from \"@angular/core\";\nexport class ThreeJsComponent {}\nThreeJsComponent.ɵfac = function ThreeJsComponent_Factory(t) {\n  return new (t || ThreeJsComponent)();\n};\nThreeJsComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n  type: ThreeJsComponent,\n  selectors: [[\"app-three-js\"]],\n  decls: 1,\n  vars: 0,\n  consts: [[\"id\", \"canvas-container\"]],\n  template: function ThreeJsComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵelement(0, \"div\", 0);\n    }\n  },\n  styles: [\"#canvas-container[_ngcontent-%COMP%] {\\r\\n    width: 100%;\\r\\n    height: 100%;\\r\\n  }\\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8uL3NyYy9hcHAvdGhyZWUtanMvdGhyZWUtanMuY29tcG9uZW50LmNzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtJQUNJLFdBQVc7SUFDWCxZQUFZO0VBQ2QiLCJzb3VyY2VzQ29udGVudCI6WyIjY2FudmFzLWNvbnRhaW5lciB7XHJcbiAgICB3aWR0aDogMTAwJTtcclxuICAgIGhlaWdodDogMTAwJTtcclxuICB9Il0sInNvdXJjZVJvb3QiOiIifQ== */\"]\n});","map":{"version":3,"mappings":";AAQA,OAAM,MAAOA,gBAAgB;AAAhBA,gBAAgB;mBAAhBA,gBAAgB;AAAA;AAAhBA,gBAAgB;QAAhBA,gBAAgB;EAAAC;EAAAC;EAAAC;EAAAC;EAAAC;IAAA;MCP7BC,yBAgTM","names":["ThreeJsComponent","selectors","decls","vars","consts","template","i0"],"sourceRoot":"","sources":["D:\\ALP_PROJECTS\\ZyloMileTech\\MainFrontend\\src\\app\\three-js\\three-js.component.ts","D:\\ALP_PROJECTS\\ZyloMileTech\\MainFrontend\\src\\app\\three-js\\three-js.component.html"],"sourcesContent":["import { Component, OnInit, ElementRef } from '@angular/core';\nimport * as THREE from 'three';\n\n@Component({\n  selector: 'app-three-js',\n  templateUrl: './three-js.component.html',\n  styleUrls: ['./three-js.component.css']\n})\nexport class ThreeJsComponent {\n\n}\n","\n<div id=\"canvas-container\">\n    <script type=\"importmap\">\n        {\n            \"imports\": {\n                \"three\": \"../build/three.module.js\",\n                \"three/addons/\": \"./jsm/\"\n            }\n        }\n    </script>\n\n    <script type=\"module\">\n        import * as THREE from 'three';\n        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n        import Stats from 'three/addons/libs/stats.module.js';\n\n        let camera, scene, renderer, object, stats;\n        let planes, planeObjects, planeHelpers;\n        let clock;\n\n        const params = {\n\n            animate: true,\n            planeX: {\n\n                constant: 0,\n                negated: false,\n                displayHelper: false\n\n            },\n            planeY: {\n\n                constant: 0,\n                negated: false,\n                displayHelper: false\n\n            },\n            planeZ: {\n\n                constant: 0,\n                negated: false,\n                displayHelper: false\n\n            }\n\n\n        };\n\n        init();\n        animate();\n\n        function createPlaneStencilGroup( geometry, plane, renderOrder ) {\n\n            const group = new THREE.Group();\n            const baseMat = new THREE.MeshBasicMaterial();\n            baseMat.depthWrite = false;\n            baseMat.depthTest = false;\n            baseMat.colorWrite = false;\n            baseMat.stencilWrite = true;\n            baseMat.stencilFunc = THREE.AlwaysStencilFunc;\n\n            // back faces\n            const mat0 = baseMat.clone();\n            mat0.side = THREE.BackSide;\n            mat0.clippingPlanes = [ plane ];\n            mat0.stencilFail = THREE.IncrementWrapStencilOp;\n            mat0.stencilZFail = THREE.IncrementWrapStencilOp;\n            mat0.stencilZPass = THREE.IncrementWrapStencilOp;\n\n            const mesh0 = new THREE.Mesh( geometry, mat0 );\n            mesh0.renderOrder = renderOrder;\n            group.add( mesh0 );\n\n            // front faces\n            const mat1 = baseMat.clone();\n            mat1.side = THREE.FrontSide;\n            mat1.clippingPlanes = [ plane ];\n            mat1.stencilFail = THREE.DecrementWrapStencilOp;\n            mat1.stencilZFail = THREE.DecrementWrapStencilOp;\n            mat1.stencilZPass = THREE.DecrementWrapStencilOp;\n\n            const mesh1 = new THREE.Mesh( geometry, mat1 );\n            mesh1.renderOrder = renderOrder;\n\n            group.add( mesh1 );\n\n            return group;\n\n        }\n\n        function init() {\n\n            clock = new THREE.Clock();\n\n            scene = new THREE.Scene();\n\n            camera = new THREE.PerspectiveCamera( 36, window.innerWidth / window.innerHeight, 1, 100 );\n            camera.position.set( 2, 2, 2 );\n\n            scene.add( new THREE.AmbientLight( 0xffffff, 0.5 ) );\n\n            const dirLight = new THREE.DirectionalLight( 0xffffff, 1 );\n            dirLight.position.set( 5, 10, 7.5 );\n            dirLight.castShadow = true;\n            dirLight.shadow.camera.right = 2;\n            dirLight.shadow.camera.left = - 2;\n            dirLight.shadow.camera.top\t= 2;\n            dirLight.shadow.camera.bottom = - 2;\n\n            dirLight.shadow.mapSize.width = 1024;\n            dirLight.shadow.mapSize.height = 1024;\n            scene.add( dirLight );\n\n            planes = [\n                new THREE.Plane( new THREE.Vector3( - 1, 0, 0 ), 0 ),\n                new THREE.Plane( new THREE.Vector3( 0, - 1, 0 ), 0 ),\n                new THREE.Plane( new THREE.Vector3( 0, 0, - 1 ), 0 )\n            ];\n\n            planeHelpers = planes.map( p => new THREE.PlaneHelper( p, 2, 0xffffff ) );\n            planeHelpers.forEach( ph => {\n\n                ph.visible = false;\n                scene.add( ph );\n\n            } );\n\n            const geometry = new THREE.TorusKnotGeometry( 0.4, 0.15, 220, 60 );\n            object = new THREE.Group();\n            scene.add( object );\n\n            // Set up clip plane rendering\n            planeObjects = [];\n            const planeGeom = new THREE.PlaneGeometry( 4, 4 );\n\n            for ( let i = 0; i < 3; i ++ ) {\n\n                const poGroup = new THREE.Group();\n                const plane = planes[ i ];\n                const stencilGroup = createPlaneStencilGroup( geometry, plane, i + 1 );\n\n                // plane is clipped by the other clipping planes\n                const planeMat =\n                    new THREE.MeshStandardMaterial( {\n\n                        color: 0xE91E63,\n                        metalness: 0.1,\n                        roughness: 0.75,\n                        clippingPlanes: planes.filter( p => p !== plane ),\n\n                        stencilWrite: true,\n                        stencilRef: 0,\n                        stencilFunc: THREE.NotEqualStencilFunc,\n                        stencilFail: THREE.ReplaceStencilOp,\n                        stencilZFail: THREE.ReplaceStencilOp,\n                        stencilZPass: THREE.ReplaceStencilOp,\n\n                    } );\n                const po = new THREE.Mesh( planeGeom, planeMat );\n                po.onAfterRender = function ( renderer ) {\n\n                    renderer.clearStencil();\n\n                };\n\n                po.renderOrder = i + 1.1;\n\n                object.add( stencilGroup );\n                poGroup.add( po );\n                planeObjects.push( po );\n                scene.add( poGroup );\n\n            }\n\n            const material = new THREE.MeshStandardMaterial( {\n\n                color: 0xFFC107,\n                metalness: 0.1,\n                roughness: 0.75,\n                clippingPlanes: planes,\n                clipShadows: true,\n                shadowSide: THREE.DoubleSide,\n\n            } );\n\n            // add the color\n            const clippedColorFront = new THREE.Mesh( geometry, material );\n            clippedColorFront.castShadow = true;\n            clippedColorFront.renderOrder = 6;\n            object.add( clippedColorFront );\n\n\n            const ground = new THREE.Mesh(\n                new THREE.PlaneGeometry( 9, 9, 1, 1 ),\n                new THREE.ShadowMaterial( { color: 0x000000, opacity: 0.25, side: THREE.DoubleSide } )\n            );\n\n            ground.rotation.x = - Math.PI / 2; // rotates X/Y to X/Z\n            ground.position.y = - 1;\n            ground.receiveShadow = true;\n            scene.add( ground );\n\n            // Stats\n            stats = new Stats();\n            document.body.appendChild( stats.dom );\n\n            // Renderer\n            renderer = new THREE.WebGLRenderer( { antialias: true } );\n            renderer.shadowMap.enabled = true;\n            renderer.setPixelRatio( window.devicePixelRatio );\n            renderer.setSize( window.innerWidth, window.innerHeight );\n            renderer.setClearColor( 0x263238 );\n            window.addEventListener( 'resize', onWindowResize );\n            document.body.appendChild( renderer.domElement );\n\n            renderer.localClippingEnabled = true;\n\n            // Controls\n            const controls = new OrbitControls( camera, renderer.domElement );\n            controls.minDistance = 2;\n            controls.maxDistance = 20;\n            controls.update();\n\n            // GUI\n            const gui = new GUI();\n            gui.add( params, 'animate' );\n\n            const planeX = gui.addFolder( 'planeX' );\n            planeX.add( params.planeX, 'displayHelper' ).onChange( v => planeHelpers[ 0 ].visible = v );\n            planeX.add( params.planeX, 'constant' ).min( - 1 ).max( 1 ).onChange( d => planes[ 0 ].constant = d );\n            planeX.add( params.planeX, 'negated' ).onChange( () => {\n\n                planes[ 0 ].negate();\n                params.planeX.constant = planes[ 0 ].constant;\n\n            } );\n            planeX.open();\n\n            const planeY = gui.addFolder( 'planeY' );\n            planeY.add( params.planeY, 'displayHelper' ).onChange( v => planeHelpers[ 1 ].visible = v );\n            planeY.add( params.planeY, 'constant' ).min( - 1 ).max( 1 ).onChange( d => planes[ 1 ].constant = d );\n            planeY.add( params.planeY, 'negated' ).onChange( () => {\n\n                planes[ 1 ].negate();\n                params.planeY.constant = planes[ 1 ].constant;\n\n            } );\n            planeY.open();\n\n            const planeZ = gui.addFolder( 'planeZ' );\n            planeZ.add( params.planeZ, 'displayHelper' ).onChange( v => planeHelpers[ 2 ].visible = v );\n            planeZ.add( params.planeZ, 'constant' ).min( - 1 ).max( 1 ).onChange( d => planes[ 2 ].constant = d );\n            planeZ.add( params.planeZ, 'negated' ).onChange( () => {\n\n                planes[ 2 ].negate();\n                params.planeZ.constant = planes[ 2 ].constant;\n\n            } );\n            planeZ.open();\n\n        }\n\n        function onWindowResize() {\n\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n\n            renderer.setSize( window.innerWidth, window.innerHeight );\n\n        }\n\n        function animate() {\n\n            const delta = clock.getDelta();\n\n            requestAnimationFrame( animate );\n\n            if ( params.animate ) {\n\n                object.rotation.x += delta * 0.5;\n                object.rotation.y += delta * 0.2;\n\n            }\n\n            for ( let i = 0; i < planeObjects.length; i ++ ) {\n\n                const plane = planes[ i ];\n                const po = planeObjects[ i ];\n                plane.coplanarPoint( po.position );\n                po.lookAt(\n                    po.position.x - plane.normal.x,\n                    po.position.y - plane.normal.y,\n                    po.position.z - plane.normal.z,\n                );\n\n            }\n\n            stats.begin();\n            renderer.render( scene, camera );\n            stats.end();\n\n        }\n\n    </script>\n</div>"]},"metadata":{},"sourceType":"module","externalDependencies":[]}